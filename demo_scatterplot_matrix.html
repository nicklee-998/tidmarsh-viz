<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
	<style type="text/css">

		svg {
			font-size: 14px;
		}

		.axis {
			shape-rendering: crispEdges;
		}

		.axis line {
			stroke: #ddd;
			stroke-width: .5px;
		}

		.axis path {
			display: none;
		}

		rect.extent {
			fill: #000;
			fill-opacity: .125;
			stroke: #fff;
		}

		rect.frame {
			fill: #fff;
			fill-opacity: .7;
			stroke: #aaa;
		}

		circle {
			fill: #ccc;
			fill-opacity: .5;
		}

		.legend circle {
			fill-opacity: 1;
		}

		.legend text {
			font-size: 18px;
			font-style: oblique;
		}

		.cell text {
			pointer-events: none;
		}

		.setosa {
			fill: #800;
		}

		.versicolor {
			fill: #080;
		}

		.virginica {
			fill: #008;
		}

	</style>
</head>
<body>
<h2 style="font-size:24px;">Tidmarsh Sensor Scatterplot</h2>
<script src="./libs/jquery-1.11.1.min.js"></script>
<script src="./libs/d3.js"></script>
<script>

	const SITE_URL = "http://chain-api.media.mit.edu/devices/?site_id=7";

	var devices;
	var csvidx, csvobj;

	// Size parameters.
	var size = 140;
	var padding = 10;
	var n = 4;

	// Position scales.
	var x = {}, y = {};

	// scatter plot parameters
	var start_time = new Date(2014, 7, 10);
	var end_time = new Date(2014, 7, 15);
	var dataset;
	var sensors = ["sht_temperature", "illuminance", "bmp_pressure", "sht_humidity"];
	var sensorColorTable;

	$(document).ready(function() {
		loadDataset();
	});

	// -----------------------------------------
	//  Load dataset
	// -----------------------------------------
	function loadDataset()
	{
		$.getJSON(SITE_URL, function(dat) {

			// TODO: That's use a little trick way to get all sensors from on request, maybe change the way in future...
			var url = SITE_URL + '&limit=' + dat.totalCount + '&offset=0';
			$.getJSON(url, function(dat2) {
				devices = dat2["_links"]["items"];

				// start loading csv files
				csvidx = 0;
				csvobj = {};
				sensorColorTable = {};
				startCSVQueue();
			});
		});
	}

	function startCSVQueue()
	{
		if(csvidx >= devices.length) {
			// 绘制散点图
			drawScatterPlot();

			return;
		}

		var url = "./res/data_sensor/" + devices[csvidx].title + "_2014.csv";
		d3.csv(url, function(dataset) {
			console.log(url);
			csvobj[devices[csvidx].title] = dataset;
			sensorColorTable[devices[csvidx].title] = getRandomColor();
			csvidx++;
			startCSVQueue();
		});
	}

	function drawScatterPlot()
	{
		// Select the dataset
		dataset = new Array();

		for (var i in csvobj) {
			var arr = csvobj[i];
			if(arr != null) {
				for(var j = 0; j < arr.length; j++) {
					var item = arr[j];
					var date = new Date(item.date);
					if(date > start_time && date < end_time && parseInt(item["sht_temperature"]) != -999) {
						dataset.push(item);
					}
				}
			}
		}

		sensors.forEach(function(sensor) {

			// Coerce values to numbers.
			dataset.forEach(function(d) {
				d[sensor] = +d[sensor];
			});

			var value = function(d) { return d[sensor] };
			var domain = [d3.min(dataset, value), d3.max(dataset, value)];
			var range = [padding / 2, size - padding / 2];

			x[sensor] = d3.scale.linear().domain(domain).range(range);
			y[sensor] = d3.scale.linear().domain(domain).range(range.reverse());
		});

		// Axes.
		var axis = d3.svg.axis()
			.ticks(5)
			.tickSize(size * n);

		// Brush.
		var brush = d3.svg.brush()
			.on("brushstart", brushstart)
			.on("brush", brush)
			.on("brushend", brushend);

		// Root panel.
		var svg = d3.select("body").append("svg:svg")
			.attr("width", 1280)
			.attr("height", 800)
			.append("svg:g")
			.attr("transform", "translate(359.5,69.5)");

		// X-axis.
		svg.selectAll("g.x.axis")
			.data(sensors)
			.enter().append("svg:g")
			.attr("class", "x axis")
			.attr("transform", function(d, i) { return "translate(" + i * size + ",0)"; })
			.each(function(d) { d3.select(this).call(axis.scale(x[d]).orient("bottom")); });

		// Y-axis.
		svg.selectAll("g.y.axis")
			.data(sensors)
			.enter().append("svg:g")
			.attr("class", "y axis")
			.attr("transform", function(d, i) { return "translate(0," + i * size + ")"; })
			.each(function(d) { d3.select(this).call(axis.scale(y[d]).orient("right")); });

		// Cell and plot.
		var cell = svg.selectAll("g.cell")
			.data(cross(sensors, sensors))
			.enter().append("svg:g")
			.attr("class", "cell")
			.attr("transform", function(d) { return "translate(" + d.i * size + "," + d.j * size + ")"; })
			.each(plot);

		// Titles for the diagonal.
		cell.filter(function(d) { return d.i == d.j; }).append("svg:text")
			.attr("x", padding)
			.attr("y", padding)
			.attr("dy", ".71em")
			.text(function(d) { return d.x; });

		function plot(p) {
			var cell = d3.select(this);

			// Plot frame.
			cell.append("svg:rect")
				.attr("class", "frame")
				.attr("x", padding / 2)
				.attr("y", padding / 2)
				.attr("width", size - padding)
				.attr("height", size - padding);

			// Plot dots.
			cell.selectAll("circle")
				.data(dataset.filter(function(d) {
					return d["sht_temperature"] != -999;
				}))
				.enter()
				.append("svg:circle")
				.style("fill", function(d) { return sensorColorTable[d.did]; })
				.attr("cx", function(d) { return x[p.x](d[p.x]); })
				.attr("cy", function(d) { return y[p.y](d[p.y]); })
				.attr("r", 3);

			// Plot brush.
			cell.call(brush.x(x[p.x]).y(y[p.y]));
		}

		// Clear the previously-active brush, if any.
		function brushstart(p) {
			if (brush.data !== p) {
				cell.call(brush.clear());
				brush.x(x[p.x]).y(y[p.y]).data = p;
			}
		}

		// Highlight the selected circles.
		function brush(p) {
			var e = brush.extent();
			svg.selectAll(".cell circle").style("fill", function(d) {
				return e[0][0] <= d[p.x] && d[p.x] <= e[1][0]
				&& e[0][1] <= d[p.y] && d[p.y] <= e[1][1]
					? sensorColorTable[d.did] : null;
			});
		}

		// If the brush is empty, select all circles.
		function brushend() {
			if (brush.empty()) svg.selectAll(".cell circle").style("fill", function(d) {
				return sensorColorTable[d.did];
			});
		}

		function cross(a, b) {
			var c = [], n = a.length, m = b.length, i, j;
			for (i = -1; ++i < n;) for (j = -1; ++j < m;) c.push({x: a[i], i: i, y: b[j], j: j});
			return c;
		}
	}

	function getRandomColor()
	{
		var letters = '0123456789ABCDEF'.split('');
		var color = '#';
		for (var i = 0; i < 6; i++ ) {
			color += letters[Math.floor(Math.random() * 16)];
		}
		return color;
	}

</script>
</body>
</html>
